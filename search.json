[
  {
    "objectID": "mediators.html",
    "href": "mediators.html",
    "title": "Mediators",
    "section": "",
    "text": "d3 = require(\"d3@7\")\ndag = import(new URL(\"js/dag-utils.js\", document.baseURI).href)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRelationships between nodes\n\nviewof strength_xz = Inputs.range([0, 1], {\n  value: 0.5, \n  step: 0.05, \n  label: html`&lt;span class=\"node node-x\"&gt;X&lt;/span&gt; → &lt;span class=\"node node-z\"&gt;Z&lt;/span&gt; strength`\n})\n\nviewof strength_zy = Inputs.range([0, 1], {\n  value: 0.5, \n  step: 0.05, \n  label: html`&lt;span class=\"node node-z\"&gt;Z&lt;/span&gt; → &lt;span class=\"node node-y\"&gt;Y&lt;/span&gt; strength`\n})\n\nviewof strength_xy = Inputs.range([0, 1], {\n  value: 0.5, \n  step: 0.05, \n  label: html`&lt;span class=\"node node-x\"&gt;X&lt;/span&gt; → &lt;span class=\"node node-y\"&gt;Y&lt;/span&gt; strength`\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdjustments\n\nviewof adjust_z = Inputs.toggle({\n  label: html`&lt;span class=\"node node-z\"&gt;Adjust for Z&lt;/span&gt; (&lt;em&gt;block indirect path&lt;/em&gt;)`\n})\n\n\n\n\n\n\n\n// ----------------\n// Status readout\n// ----------------\n{\n  const pctDirect = Math.round(y_direct_x / yMax * 100);\n  const pctMediated = Math.round(y_mediated / yMax * 100);\n  const pctZ = Math.round(y_from_z_own / yMax * 100);\n  const pctOwn = Math.max(0, 100 - pctDirect - pctMediated - pctZ);\n\n  return html`&lt;div class=\"alert alert-secondary status-readout\"&gt;\n    &lt;h5 class=\"alert-heading\"&gt;What Y contains&lt;/h5&gt;\n    &lt;table&gt;\n      &lt;tr&gt;\n        &lt;td&gt;&lt;svg width=\"12\" height=\"12\"&gt;&lt;rect width=\"12\" height=\"12\" fill=\"${dag.colorX}\"/&gt;&lt;/svg&gt;&lt;/td&gt;\n        &lt;td&gt;&lt;span class=\"node node-x\"&gt;X&lt;/span&gt;'s direct influence on &lt;span class=\"node node-y\"&gt;Y&lt;/span&gt;&lt;/td&gt;\n        &lt;td&gt;${pctDirect}%&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr&gt;\n        &lt;td&gt;&lt;svg width=\"12\" height=\"12\"&gt;\n          &lt;defs&gt;\n            &lt;pattern id=\"legend-hatch-med\" patternUnits=\"userSpaceOnUse\"\n              width=\"6\" height=\"6\" patternTransform=\"rotate(-45)\"&gt;\n              &lt;rect width=\"6\" height=\"6\" fill=\"${dag.colorX}\"/&gt;\n              &lt;line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"6\"\n                stroke=\"${dag.colorZ}\" stroke-width=\"2.5\"/&gt;\n            &lt;/pattern&gt;\n          &lt;/defs&gt;\n          &lt;rect width=\"12\" height=\"12\" fill=\"url(#legend-hatch-med)\"/&gt;\n        &lt;/svg&gt;&lt;/td&gt;\n        &lt;td&gt;&lt;span class=\"node node-x\"&gt;X&lt;/span&gt;'s influence on &lt;span class=\"node node-y\"&gt;Y&lt;/span&gt; via &lt;span class=\"node node-z\"&gt;Z&lt;/span&gt;&lt;/td&gt;\n        &lt;td&gt;${pctMediated}%&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr&gt;\n        &lt;td&gt;&lt;svg width=\"12\" height=\"12\"&gt;&lt;rect width=\"12\" height=\"12\" fill=\"${dag.colorZ}\"/&gt;&lt;/svg&gt;&lt;/td&gt;\n        &lt;td&gt;&lt;span class=\"node node-z\"&gt;Z&lt;/span&gt;'s own variation flowing to &lt;span class=\"node node-y\"&gt;Y&lt;/span&gt;&lt;/td&gt;\n        &lt;td&gt;${pctZ}%&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr&gt;\n        &lt;td&gt;&lt;svg width=\"12\" height=\"12\"&gt;&lt;rect width=\"12\" height=\"12\" fill=\"${dag.colorY}\"/&gt;&lt;/svg&gt;&lt;/td&gt;\n        &lt;td&gt;&lt;span class=\"node node-y\"&gt;Y&lt;/span&gt;'s own variation&lt;/td&gt;\n        &lt;td&gt;${pctOwn}%&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr class=\"summary ${adjust_z ? 'dimmed' : ''}\"&gt;\n        &lt;td&gt;\n          &lt;svg width=\"12\" height=\"12\"&gt;&lt;rect width=\"12\" height=\"12\" fill=\"${dag.colorX}\"/&gt;&lt;/svg&gt;\n          +\n          &lt;svg width=\"12\" height=\"12\"&gt;\n            &lt;rect width=\"12\" height=\"12\" fill=\"url(#legend-hatch-med)\"/&gt;\n          &lt;/svg&gt;\n        &lt;/td&gt;\n        &lt;td&gt;Total &lt;span class=\"node node-x\"&gt;X&lt;/span&gt; → &lt;span class=\"node node-y\"&gt;Y&lt;/span&gt; effect&lt;/td&gt;\n        &lt;td&gt;${pctDirect + pctMediated}%&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr class=\"summary ${adjust_z ? '' : 'dimmed'}\"&gt;\n        &lt;td&gt;\n          &lt;svg width=\"12\" height=\"12\"&gt;&lt;rect width=\"12\" height=\"12\" fill=\"${dag.colorX}\"/&gt;&lt;/svg&gt;\n        &lt;/td&gt;\n        &lt;td&gt;Direct-only &lt;span class=\"node node-x\"&gt;X&lt;/span&gt; → &lt;span class=\"node node-y\"&gt;Y&lt;/span&gt; effect&lt;/td&gt;\n        &lt;td&gt;${pctDirect}%&lt;/td&gt;\n      &lt;/tr&gt;\n    &lt;/table&gt;\n  &lt;/div&gt;`;\n}\n\n\n\n\n\n\n\n\n\n\nyMax = 150\nbaseVal = 50\n\nz_from_x = strength_xz * baseVal\n\ny_direct_x = strength_xy * baseVal\ny_mediated = adjust_z ? 0 : strength_zy * z_from_x\ny_from_z_own = adjust_z ? 0 : strength_zy * baseVal\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// -----------------\n// Interactive DAG\n// -----------------\n{\n  const width = 600;\n  const height = 250;\n  const nodeRadius = 36;\n\n  // Mediator: Z is between X and Y, positioned at top\n  const nodes = {\n    X: { x: 130, y: 200, label: \"X\" },\n    Z: { x: width / 2, y: 60, label: \"Z\" },\n    Y: { x: 470, y: 200, label: \"Y\" }\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"viewBox\", `0 0 ${width} ${height}`)\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .style(\"max-width\", \"100%\");\n\n  const defs = svg.append(\"defs\");\n\n  dag.addArrowMarkers(defs);\n\n  // Mediation hatch: red stripes on gold, slope downward\n  // \"X flowing through Z's territory\"\n  dag.addHatchPattern(\n    defs, \"hatch-mediated\", dag.colorX, dag.colorZ, -45\n  );\n\n  dag.addCircleClip(\n    defs, \"z-clip\", nodes.Z.x, nodes.Z.y, nodeRadius\n  );\n  dag.addCircleClip(\n    defs, \"y-clip\", nodes.Y.x, nodes.Y.y, nodeRadius\n  );\n\n  // Arrows\n  const edges = [\n    {\n      id: \"xz\", from: nodes.X, to: nodes.Z,\n      strength: strength_xz, blocked: false\n    },\n    {\n      id: \"zy\", from: nodes.Z, to: nodes.Y,\n      strength: strength_zy, blocked: adjust_z\n    },\n    {\n      id: \"xy\", from: nodes.X, to: nodes.Y,\n      strength: strength_xy, blocked: false\n    }\n  ];\n\n  for (const edge of edges) {\n    dag.drawEdge(svg, edge, nodeRadius);\n  }\n\n  // Nodes\n  // X is solid\n  dag.drawSolidNode(\n    svg, nodes.X.x, nodes.X.y, nodeRadius, dag.colorX\n  );\n\n  // Z: strength directly controls fill proportion\n  dag.drawNode(svg, nodes.Z.x, nodes.Z.y, nodeRadius, \"z-clip\", {\n    bottomUp: [\n      { prop: strength_xz, fill: dag.colorX }\n    ],\n    topDown: []\n  }, \"horizontal\", dag.colorZ);\n\n  // Y: blue base, incoming effects overlay\n  dag.drawNode(svg, nodes.Y.x, nodes.Y.y, nodeRadius, \"y-clip\", {\n    bottomUp: [\n      { prop: Math.min(y_direct_x / yMax, 1), fill: dag.colorX },\n      {\n        prop: Math.min(y_mediated / yMax, 1),\n        fill: \"url(#hatch-mediated)\"\n      }\n    ],\n    topDown: [\n      {\n        prop: Math.min(y_from_z_own / yMax, 1),\n        fill: dag.colorZ\n      }\n    ]\n  }, undefined, dag.colorY);\n\n  // Labels\n  for (const n of Object.values(nodes)) {\n    dag.drawLabel(svg, n.x, n.y, n.label);\n  }\n\n  return svg.node();\n}"
  },
  {
    "objectID": "confounders.html",
    "href": "confounders.html",
    "title": "Confounders",
    "section": "",
    "text": "d3 = require(\"d3@7\")\ndag = import(new URL(\"js/dag-utils.js\", document.baseURI).href)"
  },
  {
    "objectID": "confounders.html#how-to-adjust",
    "href": "confounders.html#how-to-adjust",
    "title": "Confounders",
    "section": "How to adjust",
    "text": "How to adjust\nTODO\n\nstratify with binary confounder and find weighted average across levels?\ncontrol for things\nipw\nmatching\ng-computation?"
  },
  {
    "objectID": "confounders.html#backdoor-adjustment-more-formally",
    "href": "confounders.html#backdoor-adjustment-more-formally",
    "title": "Confounders",
    "section": "Backdoor adjustment more formally",
    "text": "Backdoor adjustment more formally\nLet’s say that we’re interested in the causal effect of \\(X\\) on \\(Y\\), but we have a confounder \\(Z\\) that opens a backdoor path \\(X \\leftarrow Z \\rightarrow Y\\), creating a DAG that looks like this:\n\n\n\n\n\n\n\n\nFigure 1: DAG with a confounder\n\n\n\n\n\nOur target estimand is \\(P(y \\mid \\operatorname{do}(x))\\),1 or the distribution of \\(Y\\) in a world where we intervene to set \\(X = x\\). However, that \\(\\operatorname{do}(\\cdot)\\) operator represents a hypothetical intervention where we can set \\(X = x\\) directly, breaking its usual causes. In an experimental setting, that works fine—we can randomly assign people to get assigned to different values of \\(x\\). But in observational data, we don’t have control over treatment assignment and we cannot intervene.\nTo get around this, we can use Judea Pearl’s do-calculus to eliminate the \\(\\operatorname{do}(x)\\) from \\(P(y \\mid \\operatorname{do} (x))\\) and estimate the causal effect of \\(X\\) on \\(Y\\) using observational, non-experimental data.\nTo get there, we need to look at the idea of modifying graphs and define the three rules of do-calculus. We can then use those tools to derive a \\(\\operatorname{do}(\\cdot)\\)-free formula for our main estimand.\n\nGraph surgery\ndo-calculus consists of three rules that let you remove causal interventions like \\(\\operatorname{do}(\\cdot)\\) from causal estimands, allowing you to estimate causal effects from observational data.\nEach rule works by checking if specific nodes are d-separated in one of two specially modified versions of the original DAG (see Figure 2). We essentially perform surgery on these modified DAGs to remove arrows into or out of target nodes. These modified DAGs use a special kind of notation:\n\n\\(G\\): This is the original DAG; see Figure 2 (a)\n\\(G_{\\overline{X}}\\): This is \\(G\\), but with all arrows going into \\(X\\) deleted; see Figure 2 (b)\n\\(G_{\\underline{X}}\\): This is \\(G\\), but with all arrows going out of \\(X\\) deleted; see Figure 2 (c)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Original DAG, \\(G\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) \\(G_{\\overline{X}}\\) with arrows into X removed\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) \\(G_{\\underline{X}}\\) with arrows out of X removed\n\n\n\n\n\n\n\n\nFigure 2: \\(G\\), \\(G_{\\overline{X}}\\), and \\(G_{\\underline{X}}\\)\n\n\n\n\n\n\n\n\n\nTipNotation help!\n\n\n\nI like to imagine this line notation as a wall:\n\nIf the wall is on top of X like \\(\\overline{X}\\), you can’t draw any arrows going into it, so you delete anything going in\nIf the wall is on the bottom of X like \\(\\underline{X}\\), you can’t draw any arrows going out of it, so you delete anything going out\n\n\n\n\n\nThe rules of do-calculus\nPearl’s do-calculus provides three rules for eliminating \\(\\operatorname{do}(\\cdot)\\) operators from causal expressions. Each rule works by checking for d-separation in either \\(G_{\\overline{X}}\\) or \\(G_{\\underline{X}}\\):\n\nRule 1 (Ignore an observation) We can ignore an extra observed variable \\(Z\\) if it is d-separated from \\(Y\\) in \\(G_{\\overline{X}}\\) (the graph with arrows into \\(X\\) removed):\n\\[\nP(y \\mid \\operatorname{do}(x), z) = P(y \\mid \\operatorname{do}(x)) \\quad \\text{if } (Y \\perp Z \\mid X)_{G_{\\overline{X}}}\n\\]\n\n\nRule 2 (Treat an intervention as an observation) We can replace \\(\\operatorname{do}(x)\\) with simply observing \\(x\\) if, after removing X’s outgoing edges, \\(X\\) and \\(Y\\) are d-separated given the covariates:\n\\[\nP(y \\mid \\operatorname{do}(x), z) = P(y \\mid x, z) \\quad \\text{if } (Y \\perp X \\mid Z)_{G_{\\underline{X}}}\n\\]\n\n\nRule 3 (Ignore an intervention) We can drop \\(\\operatorname{do}(x)\\) entirely if, after removing X’s incoming edges, \\(X\\) and \\(Y\\) are d-separated given the covariates:\n\\[\nP(y \\mid \\operatorname{do}(x), z) = P(y \\mid z) \\quad \\text{if } (Y \\perp X \\mid Z)_{G_{\\overline{X}}}\n\\]\n\n\n\n\n\n\n\nNote 1: These formulas are flexible\n\n\n\nWith all three of these rules, the variables names are interchangeable depending on the relationships in the DAG: \\(X\\), \\(Y\\), and \\(Z\\) can stand for any sets of variables. Additionally, the conditioning set (the \\(z\\) term) could be empty (e.g. \\(Z \\rightarrow Y\\) with no other nodes involved).\n\n\n\n\nDeriving the backdoor formula\nWith the rules of do-calculus, we can take our estimand of interest—the effect of \\(X\\) on \\(Y\\), or \\(P(y \\mid \\operatorname{do}(x))\\)—and transform it into a do-free statement that deals with the confounding from \\(Z\\).\n\nStep 1: Incorporate \\(Z\\) into \\(P(y \\mid \\operatorname{do}(x))\\)\nTo adjust for the confounder \\(Z\\), we need to incorporate it into the formula for our estimand. We do this by considering the joint distribution of \\(Y\\) and \\(Z\\) in a world where \\(X\\) occurs through an intervention, or \\(P(y, z \\mid \\operatorname{do}(x))\\). This gives us the probability that \\(Y = y\\) and \\(Z = z\\) simultaneously when we force \\(X = x\\).\nTo get our target \\(P(y \\mid \\operatorname{do}(x))\\) from this joint distribution, we marginalize over \\(Z\\), or sum over all possible values of \\(Z\\):\n\\[\n{\\color{blue} P(y \\mid \\operatorname{do}(x))} = \\sum_z {\\color{red} P(y, z \\mid \\operatorname{do}(x))}\n\\tag{1}\\]\nOur estimand now includes \\(Z\\), but this joint distribution equation is hard to work with. We need to break it smaller, more manageable pieces and separate \\(y\\) and \\(x\\). Using the chain rule of probability (which applies to interventional distributions just as it does to observational ones), we can expand out Equation 1:\n\\[\n{\\color{red} P(y, z \\mid \\operatorname{do}(x))} = {\\color{orange} P(y \\mid \\operatorname{do}(x), z) \\times P(z \\mid \\operatorname{do}(x))}\n\\tag{2}\\]\nWe can substitute that expanded version back into Equation 1:\n\\[\n{\\color{blue} P(y \\mid \\operatorname{do}(x))} = \\sum_z {\\color{orange} P(y \\mid \\operatorname{do}(x), z) \\times P(z \\mid \\operatorname{do}(x))}\n\\tag{3}\\]\nOr without colors:\n\\[\nP(y \\mid \\operatorname{do}(x)) = \\sum_z P(y \\mid \\operatorname{do}(x), z) \\times P(z \\mid \\operatorname{do}(x))\n\\tag{4}\\]\nNow we have two \\(\\operatorname{do}(\\cdot)\\)-based quantities that we cannot directly estimate from data:\n\n\\(P(y \\mid \\operatorname{do}(x), z)\\): “Given that we intervene on \\(X\\) and observe \\(Z = z\\), what’s the probability of \\(Y = y\\)?”\n\\(P(z \\mid \\operatorname{do}(x))\\): “In a world where we intervene on \\(X\\), what’s the probability that \\(Z = z\\)?”\n\nOur next job is to use the rules of do-calculus to remove those \\(\\operatorname{do}(\\cdot)\\) interventions.\n\n\nStep 2: Applying Rule 2 to \\(P(y \\mid \\operatorname{do}(x), z)\\)\nAccording to Rule 2, we can replace an interventional \\(\\operatorname{do}(x)\\) with a regular observed \\(x\\) if we meet specific conditions in \\(G_{\\underline{X}}\\), or the graph with all arrows out of \\(X\\) deleted: \\(Y\\) must be d-separated from \\(X\\), given the covariates \\(Z\\). Here’s what \\(G_{\\underline{X}}\\) looks like:\n\n\n\n\n\n\n\n\nFigure 3: Check d-separation of \\(X\\) and \\(Y\\) given \\(Z\\) in \\(G_{\\underline{X}}\\)\n\n\n\n\n\nThe only path between \\(X\\) and \\(Y\\) in \\(G_{\\underline{X}}\\) is \\(X \\leftarrow Z \\rightarrow Y\\). Adjusting for \\(Z\\) blocks this path, so \\((Y \\perp X \\mid Z)_{G_{\\underline{X}}}\\) holds. That means that we can swap out \\(\\operatorname{do}(x)\\) for a regular observed \\(x\\):\n\\[\nP(y \\mid \\operatorname{do}(x), z) = P(y \\mid x, z)\n\\]\n\n\nStep 3: Applying Rule 3 to \\(P(z \\mid \\operatorname{do}(x))\\)\nAccording to Rule 3, we can remove a \\(\\operatorname{do}(\\cdot)\\) operator if we meet specific conditions in \\(G_{\\overline{X}}\\), or the graph with all arrows into \\(X\\) deleted: \\(Z\\) must be d-separated from \\(X\\) in \\(G_{\\overline{X}}\\).\n\n\n\n\n\n\nNoteWait, this doesn’t exactly match Rule 3??\n\n\n\nRule 3 officially talks about independence between \\(X\\) and \\(Y\\), but here we’re talking about \\(X\\) and \\(Z\\). What gives?\nRemember from Tip 1 that these variable names are flexible. We don’t have to look only at \\(X\\) and \\(Y\\)—any nodes can stand in for those. In this case, we care about the relationship between \\(Z\\) and \\(X\\), where the “outcome” variable is \\(Z\\) instead of \\(Y\\).\nAdditionally, technically Rule 3 includes conditioning set \\(z\\): \\(P(y \\mid \\operatorname{do}(x), z)\\). However, the \\(z\\) term in the formula can be empty. In this case, \\(Y\\) is related to \\(X\\) and \\(Z\\) as a collider and, accordingly, we don’t adjust for it, so we can leave it out of the equation. Thus, we can take this official expression from Rule 3:\n\\[\nP(y \\mid \\operatorname{do}(x), z)\n\\]\nand modify it by\n\nswitching the “outcome” variable to \\(Z\\), so \\(y\\) becomes \\(z\\), and\nusing an empty conditioning set, so the “\\(z\\)” in \\(P(y \\mid \\operatorname{do}(x), z)\\) disappears\n\n…resulting in\n\\[\nP(z \\mid \\operatorname{do}(x))\n\\]\nfor this special case.\n\n\n\n\n\n\n\n\n\n\nFigure 4: Check d-separation of \\(Z\\) and \\(X\\) in \\(G_{\\overline{X}}\\)\n\n\n\n\n\nThe only path between \\(Z\\) and \\(X\\) in \\(G_{\\overline{X}}\\) is \\(Z \\rightarrow Y \\leftarrow X\\). In this case, \\(Y\\) is a collider and since we don’t adjust for or condition on colliders, that pathway is blocked and \\((Z \\perp X)_{G_{\\overline{X}}}\\) holds. That means that we can completely eliminate \\(\\operatorname{do}(x)\\):\n\\[\nP(z \\mid \\operatorname{do}(x)) = P(z)\n\\]\n\n\nStep 4: Final formula\nFinally we can substitute both do-free results back into our original expression from Equation 4:\n\\[\n\\begin{aligned}\nP(y \\mid \\operatorname{do}(x)) &= \\sum_z \\underbrace{P(y \\mid \\operatorname{do}(x), z)}_{\\text{Rule 2}} \\times \\underbrace{P(z \\mid \\operatorname{do}(x))}_{\\text{Rule 3}} \\\\\n&= \\sum_z \\underbrace{P(y \\mid x, z)}_{\\text{Rule 2}} \\times \\underbrace{P(z)}_{\\text{Rule 3}}\n\\end{aligned}\n\\]\nThis gives us the official backdoor adjustment formula:\n\\[\n\\boxed{\\rule{0pt}{1.5em}\\;\\; P(y \\mid \\operatorname{do}(x)) = \\sum_z P(y \\mid x, z) \\times P(z) \\;\\;}\n\\]\nAll \\(\\operatorname{do}(\\cdot)\\) operators are gone and every term on the right-hand side is an ordinary observational value. This means that we can estimate the causal effect of \\(X\\) on \\(Y\\) from observational data as long as we measure and adjust for \\(Z\\)."
  },
  {
    "objectID": "confounders.html#footnotes",
    "href": "confounders.html#footnotes",
    "title": "Confounders",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nStrictly speaking, that’s not actually true! \\(P(y \\mid \\operatorname{do}(x))\\) is an interventional distribution, while causal effects or estimands are contrasts of that distribution, like \\(E[Y \\mid \\operatorname{do}(x = 1)] - E[Y \\mid \\operatorname{do}(x = 0)]\\). But for the sake of simplicity, we’ll pretend.↩︎"
  },
  {
    "objectID": "colliders.html",
    "href": "colliders.html",
    "title": "Colliders",
    "section": "",
    "text": "d3 = require(\"d3@7\")\njStat = require(\"jstat@1.9.6\")\ndag = import(new URL(\"js/dag-utils.js\", document.baseURI).href)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRelationships between nodes\n\nviewof strength_xz = Inputs.range([0, 1], {\n  value: 0.5, \n  step: 0.05, \n  label: html`&lt;span class=\"node node-x\"&gt;X&lt;/span&gt; → &lt;span class=\"node node-z\"&gt;Z&lt;/span&gt; strength`\n})\n\nviewof strength_yz = Inputs.range([0, 1], {\n  value: 0.5, \n  step: 0.05, \n  label: html`&lt;span class=\"node node-y\"&gt;Y&lt;/span&gt; → &lt;span class=\"node node-z\"&gt;Z&lt;/span&gt; strength`\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRelationship between X and Y\n\nviewof xy_exists = Inputs.toggle({\n  label: html`&lt;span class=\"node node-x\"&gt;X&lt;/span&gt; → &lt;span class=\"node node-y\"&gt;Y&lt;/span&gt; exists (&lt;em&gt;true causal effect&lt;/em&gt;)`\n})\n\nviewof strength_xy = Inputs.range([0, 1], {\n  value: 0.3, \n  step: 0.05,\n  label: html`&lt;span class=\"node node-x\"&gt;X&lt;/span&gt; → &lt;span class=\"node node-y\"&gt;Y&lt;/span&gt; strength`\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdjustments\n\nviewof adjust_z = Inputs.toggle({\n  label: html`&lt;span class=\"node node-z\"&gt;Adjust for Z&lt;/span&gt; (&lt;em&gt;or \"condition on\"&lt;/em&gt; &lt;span class=\"node node-z\"&gt;Z&lt;/span&gt;)`\n})\n\n\n\n\n\n\n\n// ----------------\n// Status readout\n// ----------------\n{\n  const trueEffect = xy_exists ? strength_xy : 0;\n\n  // Helper functions for formatting true negative signs\n  const fmt_number = (x, d = 3) =&gt;\n    (x &lt; 0 ? \"\\u2212\" : \"\") + Math.abs(x).toFixed(d);\n  const fmt_signed = (x, d = 3) =&gt;\n    (x &gt;= 0 ? \"+\" : \"\\u2212\") + Math.abs(x).toFixed(d);\n  \n  const bias = slope_cond - slope_all;\n\n  return html`&lt;div class=\"alert alert-secondary status-readout\"&gt;\n    &lt;h5 class=\"alert-heading\"&gt;Observed effects&lt;/h5&gt;\n    &lt;table&gt;\n      &lt;tr&gt;\n        &lt;td&gt;True &lt;span class=\"node node-x\"&gt;X&lt;/span&gt; → &lt;span class=\"node node-y\"&gt;Y&lt;/span&gt; effect&lt;/td&gt;\n        &lt;td&gt;${trueEffect === 0 ? \"none\" : fmt_number(trueEffect, 2)}&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr&gt;\n        &lt;td&gt;Overall slope&lt;/td&gt;\n        &lt;td&gt;${fmt_number(slope_all)}&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr class=\"summary ${adjust_z ? '' : 'dimmed'}\"&gt;\n        &lt;td&gt;Apparent slope (conditioning on &lt;span class=\"node node-z\"&gt;Z&lt;/span&gt;)&lt;/td&gt;\n        &lt;td&gt;${adjust_z ? fmt_number(slope_cond) : \"—\"}&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr&gt;\n        &lt;td&gt;N (selected / total)&lt;/td&gt;\n        &lt;td&gt;${adjust_z ? html`${n_selected} / ${simData.length}` : html`${simData.length} / ${simData.length}`}&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr class=\"${adjust_z ? '' : 'dimmed'}\"&gt;\n        &lt;td&gt;Bias introduced&lt;/td&gt;\n        &lt;td&gt;${adjust_z\n          ? html`&lt;span class=\"${Math.abs(bias) &gt; 0.05 ? 'text-danger' : ''}\"&gt;${fmt_signed(bias)}&lt;/span&gt;`\n          : \"—\"\n        }&lt;/td&gt;\n      &lt;/tr&gt;\n    &lt;/table&gt;\n  &lt;/div&gt;`;\n}\n\n\n\n\n\n\n\n\n\n\n// Javascript doesn't have native seed functions like set.seed(), so we make one here\n_seed = {\n  // Mulberry32 seeded PRNG\n  function mulberry32(a) {\n    return () =&gt; {\n      a |= 0; a = a + 0x6D2B79F5 | 0;\n      let t = Math.imul(a ^ a &gt;&gt;&gt; 15, 1 | a);\n      t = t + Math.imul(t ^ t &gt;&gt;&gt; 7, 61 | t) ^ t;\n      return ((t ^ t &gt;&gt;&gt; 14) &gt;&gt;&gt; 0) / 4294967296;\n    }\n  }\n\n  const rng = mulberry32(674751);  // From random.org\n  const N = 500;\n  const randn = (sd = 1) =&gt;\n    jStat.normal.inv(rng() * 0.998 + 0.001, 0, sd);\n\n  return {\n    xVals: Array.from({ length: N }, () =&gt; randn()),\n    noiseY: Array.from({ length: N }, () =&gt; randn()),\n    noiseZ: Array.from({ length: N }, () =&gt; randn(0.5))\n  };\n}\n\n\n\n\n\n\n\n// ----------------\n// Simulated data\n// ----------------\n// Z is binary: 1 if the latent combination exceeds 0\nsimData = {\n  const { xVals, noiseY, noiseZ } = _seed;\n  const N = xVals.length;\n  const beta = xy_exists ? strength_xy : 0;\n\n  return xVals.map((x, i) =&gt; {\n    const y = beta * x + noiseY[i];\n    const z_latent = strength_xz * x + strength_yz * y + noiseZ[i];\n    const z = z_latent &gt; 0 ? 1 : 0;\n    return { x, y, z, group: z === 1 ? \"Z = 1\" : \"Z = 0\" };\n  });\n}\n\n\n\n\n\n\n\nz1_points = simData.filter(d =&gt; d.z === 1)\nz0_points = simData.filter(d =&gt; d.z === 0)\nselected = adjust_z ? z1_points : simData\nn_selected = selected.length\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ols_slope(data) {\n  if (data.length &lt; 3) return 0;\n  const xs = data.map(d =&gt; d.x);\n  const ys = data.map(d =&gt; d.y);\n  const r = jStat.corrcoeff(xs, ys);\n  return r * jStat.stdev(ys, true) / jStat.stdev(xs, true);\n}\n\nslope_all = ols_slope(simData)\nslope_cond = ols_slope(selected)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// -----------------\n// Interactive DAG\n// -----------------\n{\n  const width = 600;\n  const height = 250;\n  const nodeRadius = 36;\n\n  const nodes = {\n    X: { x: 130, y: 200, label: \"X\" },\n    Z: { x: width / 2, y: 60, label: \"Z\" },\n    Y: { x: 470, y: 200, label: \"Y\" }\n  };\n\n  const svg = d3.create(\"svg\")\n    .attr(\"viewBox\", `0 0 ${width} ${height}`)\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .style(\"max-width\", \"100%\");\n\n  const defs = svg.append(\"defs\");\n\n  dag.addArrowMarkers(defs);\n\n  // Arrows\n  const edges = [\n    {\n      id: \"xz\", from: nodes.X, to: nodes.Z,\n      strength: strength_xz, blocked: false\n    },\n    {\n      id: \"yz\", from: nodes.Y, to: nodes.Z,\n      strength: strength_yz, blocked: false\n    }\n  ];\n\n  if (xy_exists) {\n    edges.push({\n      id: \"xy\", from: nodes.X, to: nodes.Y,\n      strength: strength_xy, blocked: false\n    });\n  }\n\n  for (const edge of edges) {\n    dag.drawEdge(svg, edge, nodeRadius);\n  }\n\n  // Add highlighted area behind X and Y when adjusting for Z\n  if (adjust_z) {\n    const padX = 8;\n    const padY = 10;\n    const left = nodes.X.x - nodeRadius - padX;\n    const right = nodes.Y.x + nodeRadius + padX;\n    const top = nodes.X.y - nodeRadius - padY;\n    const h = (nodeRadius + padY) * 2;\n    const w = right - left;\n\n    svg.append(\"rect\")\n      .attr(\"x\", left)\n      .attr(\"y\", top)\n      .attr(\"width\", w)\n      .attr(\"height\", h)\n      .attr(\"rx\", h / 2)\n      .attr(\"ry\", h / 2)\n      .attr(\"fill\", dag.colorZ)\n      .attr(\"opacity\", 0.18);\n  }\n\n  // Nodes\n  dag.drawSolidNode(\n    svg, nodes.X.x, nodes.X.y, nodeRadius, dag.colorX\n  );\n\n  dag.drawSolidNode(\n    svg, nodes.Y.x, nodes.Y.y, nodeRadius, dag.colorY\n  );\n\n  // Z: solid gold, semi-transparent when not conditioning,\n  // fully opaque when conditioning\n  dag.drawSolidNode(\n    svg, nodes.Z.x, nodes.Z.y, nodeRadius, dag.colorZ,\n    adjust_z ? 1 : 0.35\n  );\n\n  // Labels\n  for (const n of Object.values(nodes)) {\n    dag.drawLabel(svg, n.x, n.y, n.label);\n  }\n\n  return svg.node();\n}\n\n\n\n\n\n\n\n// Scatterplot of points with regression line(s)\nPlot.plot({\n  width: 550,\n  height: 340,\n  style: { fontSize: \"12px\" },\n  x: { label: \"X\" },\n  y: { label: \"Y\" },\n  color: {\n    domain: [\"Z = 0\", \"Z = 1\"],\n    range: [dag.colorZ0, dag.colorZ]\n  },\n  marks: [\n    // Faded excluded points (Z = 0 when conditioning)\n    adjust_z\n      ? Plot.dot(z0_points, {\n          x: \"x\", y: \"y\",\n          fill: dag.colorZ0,\n          r: 3,\n          fillOpacity: 0.2\n        })\n      : null,\n\n    // Active points\n    Plot.dot(selected, {\n      x: \"x\", y: \"y\",\n      fill: \"group\",\n      r: 4,\n      fillOpacity: 0.75,\n      stroke: \"#fff\",\n      strokeWidth: 0.5\n    }),\n\n    // Overall regression line\n    Plot.linearRegressionY(simData, {\n      x: \"x\", y: \"y\",\n      stroke: \"#8b8b99\",\n      strokeWidth: 2\n    }),\n\n    // Conditioned regression line\n    adjust_z\n      ? Plot.linearRegressionY(z1_points, {\n          x: \"x\", y: \"y\",\n          stroke: dag.apparentLine,\n          strokeWidth: 2.5,\n          strokeDasharray: \"8 5\"\n        })\n      : null\n  ].filter(Boolean)\n})"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Interactive DAGs",
    "section": "",
    "text": "blah blah blah"
  }
]